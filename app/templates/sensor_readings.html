{% extends "base.html" %}

{% block content %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
<div class="row">
    <div class="col-md-12">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h1>Sensor Readings</h1>
            <select id="timescale-select" class="form-select w-auto" onchange="updateCharts()">
                <option value="5">Last 5 Minutes</option>
                <option value="10" selected>Last 10 Minutes</option>
                <option value="60">Last Hour</option>
                <option value="1440">Last 24 Hours</option>
            </select>
        </div>
        <p class="text-muted">Monitor sensor readings and manage calibration.</p>
        
        <div id="calibration-container">
            <div class="text-center">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Point Modal -->
<div class="modal fade" id="addPointModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Add Calibration Point</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="add-point-form">
                    <input type="hidden" id="modal-sensor-name">
                    <div class="mb-3">
                        <label for="measured-val" class="form-label">Measured Value (Raw)</label>
                        <input type="number" step="any" class="form-control" id="measured-val" required>
                        <div class="form-text">The value currently reported by the sensor.</div>
                    </div>
                    <div class="mb-3">
                        <label for="actual-val" class="form-label">Actual Value (Reference)</label>
                        <input type="number" step="any" class="form-control" id="actual-val" required>
                        <div class="form-text">The true value measured by a reference instrument.</div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="submitAddPoint()">Save</button>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        loadCalibration();
        updateStatus();
        setInterval(updateStatus, 2000);
    });
    
    let addModal;
    let currentValues = {};
    let charts = {};
    let calCharts = {};
    let chartInterval = null;

    function updateCharts() {
        const minutes = document.getElementById('timescale-select').value;
        const end = new Date();
        const start = new Date(end.getTime() - minutes * 60000);
        
        fetch(`/api/history?start=${start.toISOString()}&end=${end.toISOString()}`)
            .then(response => response.json())
            .then(data => {
                // We use the raw ISO timestamps for the x-axis
                const timestamps = data.timestamps; 
                
                for (const [sensor, values] of Object.entries(data.sensors)) {
                    const ctx = document.getElementById(`chart-${sensor}`);
                    if (!ctx) continue;
                    
                    // Create data points {x: timestamp, y: value}
                    const dataPoints = timestamps.map((t, i) => ({
                        x: t,
                        y: values[i]
                    }));

                    if (charts[sensor]) {
                        charts[sensor].data.datasets[0].data = dataPoints;
                        charts[sensor].options.scales.x.min = start.toISOString();
                        charts[sensor].options.scales.x.max = end.toISOString();
                        charts[sensor].update();
                    } else {
                        charts[sensor] = new Chart(ctx, {
                            type: 'line',
                            data: {
                                datasets: [{
                                    label: sensor,
                                    data: dataPoints,
                                    borderColor: 'rgb(75, 192, 192)',
                                    tension: 0.1,
                                    pointRadius: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        type: 'time',
                                        time: {
                                            unit: minutes <= 60 ? 'minute' : 'hour',
                                            displayFormats: {
                                                minute: 'HH:mm',
                                                hour: 'MM/dd HH:mm'
                                            }
                                        },
                                        min: start.toISOString(),
                                        max: end.toISOString()
                                    },
                                    y: {
                                        beginAtZero: false
                                    }
                                },
                                plugins: {
                                    legend: {
                                        display: false
                                    }
                                }
                            }
                        });
                    }
                }
            });
    }

    function updateStatus() {
        fetch('/api/status')
            .then(response => response.json())
            .then(data => {
                currentValues = data.sensors; // Store for modal
                for (const [sensor, val] of Object.entries(data.sensors)) {
                    const rawEl = document.getElementById(`raw-${sensor}`);
                    const calEl = document.getElementById(`cal-${sensor}`);
                    const timeEl = document.getElementById(`time-${sensor}`);
                    
                    if (val) {
                        if (rawEl) rawEl.textContent = val.raw.toFixed(2);
                        if (calEl) calEl.textContent = val.calibrated.toFixed(2);
                        if (timeEl && val.timestamp) {
                            const date = new Date(val.timestamp);
                            timeEl.textContent = date.toLocaleTimeString();
                        }
                    }
                }
            })
            .catch(err => console.error('Error fetching status:', err));
    }

    function loadCalibration() {
        fetch('/api/calibration')
            .then(response => response.json())
            .then(data => {
                const container = document.getElementById('calibration-container');
                
                // Destroy existing charts before clearing DOM
                for (const sensor in charts) {
                    if (charts[sensor]) {
                        charts[sensor].destroy();
                    }
                }
                charts = {}; // Reset charts object
                
                // Destroy existing calibration charts
                for (const sensor in calCharts) {
                    if (calCharts[sensor]) {
                        calCharts[sensor].destroy();
                    }
                }
                calCharts = {};

                container.innerHTML = '';

                // Sort keys
                const sensors = Object.keys(data).sort();

                sensors.forEach(sensor => {
                    const sensorData = data[sensor];
                    const points = sensorData.points;
                    const card = document.createElement('div');
                    card.className = 'card mb-4';
                    
                    const header = document.createElement('div');
                    header.className = 'card-header d-flex justify-content-between align-items-center';
                    header.innerHTML = `<h5 class="mb-0">${sensorData.readable_name} <small class="text-muted" style="font-size: 0.8em;">(${sensor})</small></h5>
                        <div>
                            <span class="badge bg-info text-dark me-2" id="time-${sensor}">--:--:--</span>
                            <span class="badge bg-secondary me-2">Raw: <span id="raw-${sensor}">--</span></span>
                            <span class="badge bg-success me-2">Cal: <span id="cal-${sensor}">--</span></span>
                            <button class="btn btn-sm btn-primary" onclick="openAddModal('${sensor}')">Add Point</button>
                        </div>`;
                    
                    const body = document.createElement('div');
                    body.className = 'card-body';
                    
                    // Add Chart Container
                    const chartContainer = document.createElement('div');
                    chartContainer.style.height = '200px';
                    chartContainer.className = 'mb-3';
                    chartContainer.innerHTML = `<canvas id="chart-${sensor}"></canvas>`;
                    body.appendChild(chartContainer);
                    
                    if (points.length === 0) {
                        const p = document.createElement('p');
                        p.className = 'text-muted';
                        p.textContent = 'No calibration points. Using raw values.';
                        body.appendChild(p);
                    } else {
                        // Calibration Plot Checkbox
                        const checkDiv = document.createElement('div');
                        checkDiv.className = 'form-check form-switch mb-2';
                        checkDiv.innerHTML = `
                            <input class="form-check-input" type="checkbox" id="show-cal-${sensor}" onchange="toggleCalPlot('${sensor}')">
                            <label class="form-check-label" for="show-cal-${sensor}">Show Calibration Plot</label>
                        `;
                        body.appendChild(checkDiv);

                        // Calibration Plot Container
                        const calPlotContainer = document.createElement('div');
                        calPlotContainer.id = `cal-plot-container-${sensor}`;
                        calPlotContainer.style.display = 'none';
                        calPlotContainer.style.height = '200px';
                        calPlotContainer.className = 'mb-3';
                        calPlotContainer.innerHTML = `<canvas id="cal-chart-${sensor}"></canvas>`;
                        body.appendChild(calPlotContainer);

                        const table = document.createElement('table');
                        table.className = 'table table-striped';
                        table.innerHTML = `<thead><tr><th>Measured (Raw)</th><th>Actual (Ref)</th><th>Action</th></tr></thead><tbody></tbody>`;
                        
                        const tbody = table.querySelector('tbody');
                        points.forEach(p => {
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td>${p.measured}</td>
                                <td>${p.actual}</td>
                                <td><button class="btn btn-sm btn-danger" onclick="deletePoint(${p.id})">Delete</button></td>
                            `;
                            tbody.appendChild(row);
                        });
                        body.appendChild(table);
                    }
                    
                    card.appendChild(header);
                    card.appendChild(body);
                    container.appendChild(card);
                });
                
                // Create Calibration Charts
                sensors.forEach(sensor => {
                    const sensorData = data[sensor];
                    const points = sensorData.points;
                    if (points.length > 0) {
                        const ctx = document.getElementById(`cal-chart-${sensor}`);
                        if (ctx) {
                            const sortedPoints = [...points].sort((a, b) => a.measured - b.measured);
                            const plotData = sortedPoints.map(p => ({x: p.measured, y: p.actual}));
                            
                            calCharts[sensor] = new Chart(ctx, {
                                type: 'scatter',
                                data: {
                                    datasets: [{
                                        label: 'Calibration Points',
                                        data: plotData,
                                        backgroundColor: 'rgba(255, 99, 132, 1)',
                                        showLine: true,
                                        borderColor: 'rgba(255, 99, 132, 1)',
                                        tension: 0
                                    }]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    scales: {
                                        x: {
                                            type: 'linear',
                                            position: 'bottom',
                                            title: { display: true, text: 'Measured (Raw)' }
                                        },
                                        y: {
                                            title: { display: true, text: 'Actual (Ref)' }
                                        }
                                    }
                                }
                            });
                        }
                    }
                });

                // Trigger an immediate status update to fill values
                updateStatus();
                updateCharts();
                if (chartInterval) clearInterval(chartInterval);
                chartInterval = setInterval(updateCharts, 30000); // Update charts every 30s
            })
            .catch(err => console.error('Error loading calibration:', err));
    }

    function toggleCalPlot(sensor) {
        const container = document.getElementById(`cal-plot-container-${sensor}`);
        const checkbox = document.getElementById(`show-cal-${sensor}`);
        if (checkbox.checked) {
            container.style.display = 'block';
            if (calCharts[sensor]) {
                calCharts[sensor].resize();
            }
        } else {
            container.style.display = 'none';
        }
    }

    function openAddModal(sensor) {
        document.getElementById('modal-sensor-name').value = sensor;
        
        // Auto-populate raw value
        if (currentValues[sensor]) {
             document.getElementById('measured-val').value = currentValues[sensor].raw;
        } else {
             document.getElementById('measured-val').value = '';
        }

        document.getElementById('actual-val').value = '';
        
        if (!addModal) {
            addModal = new bootstrap.Modal(document.getElementById('addPointModal'));
        }
        addModal.show();
    }

    function submitAddPoint() {
        const sensor = document.getElementById('modal-sensor-name').value;
        const measured = parseFloat(document.getElementById('measured-val').value);
        const actual = parseFloat(document.getElementById('actual-val').value);

        if (isNaN(measured) || isNaN(actual)) {
            alert('Please enter valid numbers');
            return;
        }

        fetch('/api/calibration', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sensor, measured, actual })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                addModal.hide();
                loadCalibration();
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        });
    }

    function deletePoint(id) {
        if (!confirm('Are you sure you want to delete this calibration point?')) return;

        fetch(`/api/calibration/${id}`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                loadCalibration();
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        });
    }
</script>
{% endblock %}
